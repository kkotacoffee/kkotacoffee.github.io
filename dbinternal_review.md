# 本書の動機
昨今の扱うデータ量の急激な拡大によりデータベースは１つのサーバのみで構築するのは無理になってきた
そこで分散システムというDB機能を複数のサーバに配置して、それらが連携しあうことで単体DBに見せるシステムが必須となってきた

# 第一部
- データベースの内部構造を詳細に解説している
- DBはその構造ごとにそれぞれ特徴・向き不向きがある、そのた採用する際は求める機能要件とのトレードオフを考える

# 1.　基本事項
- 用語の紹介
- 行指向DBと列指向DB、取り出す向きで効率が変化
- ワイドカラムストアというJSONとその親子関係を抜き出したファミリーテーブルからなるDBもある

# 2. B-Tree
- B-Tree の優位性、望ましい特性
- ディスクベースの場合、要素の取り出しには、目的要素開始場所までディスクを回すシークと、そこからのシーケンシャルな読み取りが必要
- 効率的なTree -> 低く、ファンアウトが大きい木
- SSD の構成要素は小さい方からページ・ブロック・プレーン・ダイ
- SSD のデータアクセスにかかる時間は基本一定なので、SSD向けアルゴリズムにおいてデータの局所性は大事でない
- リバランシングは操作コストが大きいので、そこを減らしていけるかが重要

# 3. ファイルフォーマット
- Tree とその値がどのようにメモリにマッピングされているかを見る
- 固定長レコードは key, value, 子ページへのポインタの３要素が、各レコードごとにまとまって、それが繋げられてページに入っている
- スロット化ページは、ヘッダ・ポインタ（オフセット）・セルの構成から成るページ、これにより、レコードの削除等があっても、値がどこから始まっているかの参照が楽になる（すなわち、編集も楽になる）
- セルにはキーセル・キーバリューセルがあり、
    - セルタイプ
    - キータイプ
    - キーバイト列
    に加え、キーセルは
    - 子セルへのポインタ
    を、キーバリューセルは
    - バリュータイプ
    - バリューバイト列
を持つ
- オフセットは左から、セルは右から埋めていくことでメモリ管理がしやすくなる
- キー順を保つために、オフセット・セルのペアが追加された際にはオフセットを書き換えることで順序を保っている
- 空いたセルは利用可能リストがポインタで管理し、一定のルールに従って（空いているセルにピッタリ入りそうな値を入れるなど）再利用される

# 4. B-tree の（メモリ上への）実装
- 実装の際、ページヘッダはDBごとに様々な使われ方をする
    - マジックナンバー（検証と正常性検査）
    - 兄弟リンク（シークの手間削減、スプリットマージ時には更新の手間が増える）
    - 右端のポインタ（各キーにポインタを割り当てると最後のキーより大きい集合へのポインタを持つ場所がないため）
    - ノードハイキー（キーの最大値を格納することで、各キー K_i に割り当てるポインタ p の範囲を K_{i-1} <= p < K_i にでき、右端のポインタと同じ役割を果たす）
    - オーバーフローページ（容量が足りず格納しきれないページのはみ出た部分を格納する）

- 探索時は間接ポインタを用いる、セルは挿入順に並んでいるが、セルのオフセットは論理的にソートされているためオフセットと対応するセルの値を用いて探索を行う
- 探索時にパンクズリストとして各階層で選択したインデックスを記憶しておくことで操作が楽になる
- スプリット・マージの前にリバランシングをすることでコスト償却ができる、アルゴリズムはDBによって異なる
- プライマリインデックスキーは基本的に単調増加インクリメントであるため、新たな要素の追加位置は右端になり、ほとんどのスプリットは右端のノードで行われるため、効率化できる。
- このおかげでノードの位置を完全に構築・固定することができるバルクロードも可能となる
- 圧縮はメモリオーバーヘッド・圧縮展開性能・圧縮率の4要素が重要
- 要素の削除はセルのオフセットのみ削除されるため、使用していないセルが断片化する。これを解消するため、コンパンクション（ページの書き換え・再書き込み）が行われる


# 5. トランザクション処理とリカバリ（難しい）
- バッファプールとその書き込み先ディスクの順序には直接的な順序関係はない
- キャッシュのフラッシュ頻度とログ先行書き込み効率はトレードオフ
- 検索時に多くアクセスされるページ（ツリーの上位ノードなど）はキャッシュにロック（ピン留め）され、長い時間キャッシュ内に残る
- キャッシュサイズを大きくしたところで、退避の回数が減るとは限らない（Beladyの異常）
- 退避ポリシーはいろいろある
    - FIFO
    - LRU(lease recently used) 一番使われてないやつ
    - 2Q(2 queue LRU) - 初め第一キューに要素を入れ、もう一度呼ばれたら第一キューから第二キューに移動させることでアクセス頻度の高いページを区別
    - LRU-K ページが K 回アクセスされるまでの時間を元に判定

- 単一のアルゴリズムではなく CLOCK アルゴリズムのような巡回アルゴリズムもポリシーとして採用されている
- 循環バッファにアクセスビットを用意して参照されたらビット変更、ビットを元に判断
- 判断基準は LFU, TinyLFU では要素を入場(LRUベース)・保護観察(退避候補を保持)・保護対象の３つのキューに分け、入場キューから頻度フィルタを通して保護観察キューに送られ、保護対象との間を移動する。

- DBにおいてログ先行書き込み(Write Ahead Loggin, WAL)はリカバリの観点で重要(ARIES, Algorithm for Recovery and Isolation Exploiting Semantics)
- キャッシュからディスクに変更が同期されるまでの間情報を持っておく、すなわちDBに関する操作全てを変更前にログに書き込む
- WAL はログシーケンス番号(LSN)を持つイミュータブルで追記型のログレコードから構成される、コミットも記録されトラブルの判定に用いられる
- 一定のシーケンス番号？である（同期）チェックポイントに到達するたびにトリミングが行われ、ログレコードの永続化が行われる
- キャッシュ全体をフラッシュするのは大変なので代わりにファジーチェックポイントが用いられ、LSNを区間で区切ってフラッシュを行いlast_checkpoint に最後に成功したチェックポイントを格納する
